# 第十章 函数

本章内容：

- 函数表达式、函数声明、箭头函数
- 默认参数与扩展操作符
- 使用函数实现递归
- 使用闭包实现私有变量

在 ECMAScript 中，函数实际上是**对象**，每一个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。函数名指向函数对象的指针。

定义函数方式：

1. 函数声明
2. 函数表达式
3. 使用 Function 构造函数 (存在性能问题，不推荐使用)

## 10.1 箭头函数

使用胖箭头语法定义函数表达式：`() => {}`

箭头函数语法规则：

- 只有一个参数，可以不用括号；
- 没有参数，或者有多个参数，需要使用括号；
- 函数体使用 `{}` 可以包含多条语句；
- 函数体不使用大括号时，箭头后面只能有一行代码（赋值操作、表达式）；

::: tip 提示
箭头函数**不能使用 arguments、super、new.target，也不能用作构造函数，也没有 prototype 属性**
:::

## 10.2 函数名

函数名就是指向函数的指针。ECMAScript6 的所有函数对象对外暴露一个只读的 `name` 属性。

- 默认情况下返回函数的标识符，或者一个字符串化的变量名；
- 没有名字函数，会返回一个空的字符串；
- 如果使用 Function 构造函数创建的，则会标识成 `anonymous`;

如果函数是一个获取函数、设置函数，或者使用 `bind()` 实例化，那么表示符前面会加上一个前缀。

```js
function foo() {}
const fun = function () {};
const bar = () => {};

console.log(foo.name); // foo
console.log(fun.name); // fun
console.log(bar.name); // bar

console.log((fucntion(){}).name);

console.log(new Function().name); // anonymous

// get set
let dog = {
  years: 1,
  get age(){
    return this.years;
  },
  set age(val){
    this.years = val
  }
}

const agePropertyDes = Object.getOwnPropertyDescriptor(dog, 'age');
console.log(agePropertyDes.get.name); // 'get age'
console.log(agePropertyDes.set.name); // 'set age'
```

## 10.3 理解参数

ECMAScript 函数的参数在内部表现为一个数组。

在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象。

- **arguments 对象是一个类数组**；
- 可以访问 `arguments.length` 属性，该长度是**传入参数个数**，而非定义函数是的命名参数个数确定的；
- 严格模式下，arguments 赋值不会影响函数参数的值；

```js
"use strict";
function doadd(num1, num2) {
  arguments[1] = 10;
  console.log(arguments); // [10, 10]
  return num1 + num2;
}
doadd(10, 20);
```

:::warning 注意
ECMAScript 中所有的参数都是按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。[理解函数参数是按值传递](/javascript-technic/04.html)
:::

### 8.3.1 箭头函数中的参数

箭头函数不能使用 `arguments` 关键字，只能通过定义的命名参数访问。

```javascript
var a = [1, 2, 3];
function fn(b) {
  b = [4, 5, 6];
}
fn(a);
console.log(a); // [1, 2, 3]

var obj = {
  name: "大雄",
};
function fn(b) {
  b.name = "小熊";
}
fn(obj);
console.log(obj.name); // '小熊'
```

## 10.4 没有重载

ECMAScript 函数没有签名（接收参数的数量和类型），因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然就没有重载。

在 ECMAScript 定义多个同名函数，后定义会覆盖先定义的。可以通过检查参数数量和类型，执行不同逻辑来模拟函数重载。

```javascript
function sum(num1) {
  return num1 + 100;
}

function sum(num1, num2) {
  num2 = num2 || 100;
  return num1 + num2 + 100;
}

sum(100); // 300
```

使用函数表达式可以更确切表达，函数覆盖问题。

```javascript
var sum = function (num1) {
  return num1 + 100;
};

sum = function (num1, num2) {
  num2 = num2 || 100;
  return num1 + num2 + 100;
};

sum(100); // 300
```

## 10.5 默认参数值

在 ECMAScript5 之前，实现默认参数的常用的方式就是检测某一个参数是否等于 undefined，如果是 undefined 则以为着没有传这个参数，那就给它一个默认值。

```js
function makeKing(name) {
  name = typeof name === undefined ? "Henry" : name;
  return `King name is ${name}`;
}
```

在 ECMAScript6 之后，支持显式定义默认参数。

```js
function makeKing(name = "Henry") {
  return `King name is ${name}`;
}
```

使用默认参数函数时，**argunments 对象的值不反映参数的默认值，只反映传给函数的参数**。当然在 ES5 严格模式一样，修改命名参数也不影响 argument 时对象，它始终以调用函数时传入的值为准。

```js
function makeKing(name = "Henry") {
  name = "Louis";
  return `King  ${arguments[0]}`;
}

console.log(makeKing()); // King  undefined
console.log(makeKing("Louis")); // King  Louis
```

默认参数值并限于原始值或对象类型，也可以使用调用函数返回的值。

```js
let romanNumerals = ["Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ", "Ⅵ", "Ⅶ", "Ⅷ", "Ⅸ", "Ⅹ"];
let ordinality = 0;
function getNumerals() {
  console.log("getNumerals");
  return romanNumerals[ordinality++];
}

function makeKing(name, numerals = getNumerals()) {
  return `King ${name}-${numerals}`;
}

makeKing(); // getNumerals 'King undefined-Ⅰ'
makeking("Henry"); // getNumerals 'King Henry-Ⅱ'
makeKing("Louis", "Ⅰ"); // 'King Louis-Ⅰ'
```

:::warning 注意
函数的默认参数**只有在函数被调用时才会求值**，**不会在函数定义时求值**。而且，计算默认值的函数**只有在调用函数但未传相应参数时才会被调用**。
:::

箭头函数也可以这样使用默认参数，只不过在只有一个参数时，必须使用括号不能省略。

```js
let makeKing = (name = "Louis") => `King ${name}`;
```

### 8.5.1 默认参数作用域与暂时性死区

- **参数时按照顺序初始化的**，所以后定义默认值的参数可以引用先定义的参数；

```js
function makeKing(name = "Louis", numerals = name) {
  return `King ${name}-${numerals}`;
}
makeKing(); // 'King Louis-Louis'
```

- **参数初始化顺序遵循”暂时性死区“规则**，即前面定义的参数不能引用后面定义的；

```js
function makeKing(name = numerals, numerals = "Ⅰ") {
  return `King ${name}-${numerals}`;
}
makeKing(); // Uncaught ReferenceError: Cannot access 'numerals' before initialization
```

- **参数也存在于自己的作用域中，它们不能引用函数体的作用域**；

```js
function makeKing(name = "Louis", numerals = defaultNumerals) {
  let defaultNumerals = "Ⅰ";
  return `King ${name}-${numerals}`;
}
makeKing(); // ReferenceError: defaultNumerals is not defined
```

## 10.6 参数扩展与收集

ECMAScript6 新增扩展操作符，扩展操作符最有用场景就是函数定义中的参数列表。

### 10.6.1 扩展参数

在给函数传递参数时，有时不需要传一个数组，而是分别传入数组的元素；

```js
function sum() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }
  return sum;
}
const arr = [1, 2, 3, 4, 5, 6];
```

如果不使用扩展操作符，想把定义的数组拆分，那么就得求助于 `apply()` 方法：

`sum.apply(null, arr);`

在 ES6 中，可以通过扩展操作符对可迭代对象拆分，并将迭代返回的每一个值单独传入。

```js
sum(...arr);
```

在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数；

```js
function getProduct(a, b, c = 1) {
  return a * b * c;
}

let getSum = (a, b, c = 0) => {
  return a + b + c;
};

console.log(getProduct(...[1, 2])); // 2
console.log(getProduct(...[1, 2, 3])); // 6
console.log(getProduct(...[1, 2, 3, 4])); // 6

console.log(getSum(...[1, 2])); // 3
console.log(getSum(...[1, 2, 3])); // 6
console.log(getSum(...[1, 2, 3, 4])); // 6
```

### 10.6.2 收集参数

使用扩展操作符把不同长度的独立参数组合为一个数组。

```js
function getSum(...values) {
  return values.reduce((x, y) => x + y, 0);
}
getSum(1, 2, 3); // 6
```

:::warning 注意
收集参数前面如果有命名参数，则只收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为**最后一个参数**；
:::

## 10.7 函数声明与函数表达式

函数表达式存在**函数声明提升**，JavaScript 引擎会解析代码时，函数声明会提升到作用域的顶部；而函数表达式必须等到代码执行那一行，才会执行上下文生成函数定义；

## 10.8 函数作为值

函数不仅可以作为参数进行传递，也可以作为一个函数返回值(即：**高阶函数**)；如：函数科里化，函数缓存，防抖函数（debounce），节流函数（throttle）等。

```js
function createComparsionFunction(prototypeName) {
  return function (prev, next) {
    let value1 = prev[prototypeName];
    let value2 = next[prototypeName];

    if (value1 < value2) {
      return -1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  };
}

let data = [
  { name: "Zachary", age: 28 },
  { name: "Nicholas", age: 26 },
  { name: "Jack", age: 30 },
];
data.sort(createComparsionFunction("age"));
```

数组 data 中包含数据结构相同的多个值，默认情况下， `sort()` 方法要对这两个对象执行 `toString()`，再决定它们顺序，但这样不是预期的结果。所以通过 `createComparsionFunction()` 来创建一个比较函数，通过传递不同属性名（name 或 age）创建不同的比较函数；

## 10.9 函数内部

在 ES5 中，函数内部存在两个特殊对象：arguments 和 this，ES6 中新增了 `new.target` 属性。

### 10.9.1 arguments

arguments 是一个**类数组**对象，包含**调用函数时传入的所有参数**。只有在 `function` 关键字定义的函数事才会有该对象（箭头函数没有 arguments）。

虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，该属性指向 arguments 对象所在函数的指针。

经典阶乘函数：

```js
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

阶乘函数一般定义成递归调用的。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行必须保证函数名是 `factorial`，从而导致紧密耦合。

使用 `arguments.callee` 就是可以让函数逻辑与函数名解藕：

```js
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);
  }
}
```

重写之后的 `factorial()` 函数已经用 `arguments.callee` 代替了之前的硬编码 `factorial`。 意味着无论函数叫什么名字，都会正确引用的函数。

```js
let tfactorial = factorial;
factorial = function () {
  return 0;
};

tfactorial(5); // 120
factorial(5); // 0
```

这里，`tfactorial` 变量被赋值为 `factorial`，实际上把同一个函数的指针又保存在另一个位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果 `factorial()` 最初的版本那样不使用 `arguments.callee`，那么像上面这样调用 `tfactorial()` 就会返回 0。不过，通过将函数与名称解藕，`tfactorial()` 就可以正确计算阶乘，而 `factorial()` 则只能返回 0。

:::danger 警告
在严格模式 (en-US)下，第 5 版 ECMAScript (ES5) 禁止使用 `arguments.callee()`。当一个函数必须调用自身的时候，避免使用 `arguments.callee()`，通过要么给函数表达式一个名字，要么使用一个函数声明。
:::

### 10.9.2 this

在标准函数和箭头函数中 this 有不同的行为：

- 在标准函数中，this 引用的是把函数当成**方法调用的**上下文对象。
- 在箭头函数中，this 引用的是**定义箭头函数**的上下文。

特殊执行函数时，this 指向问题示例：

```js
// 1. 定时器 this 始终指向全局对象
function foo() {
  setTimeout(function () {
    console.log(this); // window
  }, 0);
}

// 2. 直接执行方法，this 指向全局对象
function foo() {
  console.log(this); // window
}
function bar() {
  console.log(this); // window
  foo();
}
bar();
```

:::tip 提示
在事件回调或定时回调中调用某个函数时，this 指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题；
:::

### 10.9.3 caller

在 ES5 中函数对象上添加一个属性：caller。该属性**引用的是调用当前函数的函数**.

如果一个函数 f 是在全局作用域内被调用的，则 `f.caller` 为 `null`。相反，如果一个函数是在另外一个函数作用域内被调用的，则 `f.caller` 指向调用它的那个函数。

:::danger
非标准: 该特性是非标准的，请尽量不要在生产环境中使用它！
:::

### 10.9.4 new.target

`new.target` 属性用于**检测函数或构造方法是否是通过 new 运算符被调用的**。

在通过 new 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是 `undefined`。

## 10.10 函数属性和方法

每个函数都有两个属性：length 和 prototype；

- length 属性保存函数定义的命名参数的个数。形参的数量**不包括剩余参数个数**，仅包括第一个具有默认值之前的参数个数。
- prototype 是保存引用类型所有的实例方法，所有实例共享。该属性是不可枚举，`for...in` 循环是不会返回该属性的。[第八章查看更多](/javascript-professional/08.html)。

函数的方法：

- `apply()` 方法调用一个具有给定 `this` 值的函数，以及以**一个数组（或一个类数组对象）**的形式提供的参数。
- `call()` 方法使用一个指定的 `this` 值和单独给出的**一个或多个参数(参数列表)**来调用一个函数。
- `bind()` 方法**创建一个新的函数**，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数(**参数列表**)将作为新函数的参数，供调用时使用。

## 10.11 函数表达式

函数声明和函数表达式，主要区别： **函数声明提升**。

```js
// bad
if (condition) {
  function sayHi() {
    console.log("Hi!");
  }
} else {
  function sayHi() {
    console.log("Hello!");
  }
}
```

这段代码看起来正常，事实上，这种写法在 ECMAScript 中**不是有效的语法**。JavaScript 引擎会尝试纠正适当声明。问题在不同浏览器纠正的方式不同，在大部分浏览器会忽略判断条件，直接返回第二声明。Firefox 会在 condition 为 true 时，返回第一个声明。若是换成函数表达式就不存在该问题了

```js
let sayHi;
if (condition) {
  sayHi = function () {
    console.log("Hi!");
  };
} else {
  sayHi = function () {
    console.log("Hello!");
  };
}
```

## 10.12 递归

递归函数通常的形式时一个函数通过名称调用自己。

[经典阶乘](/javascript-professional/10.html#_10-9-1-arguments)代码中，使用 `arguments.callee` 可以确保函数内部正确调用，避免递归函数赋值给其他变量问题。

不过，在严格模式下 `arguments.callee` 访问会出错的，可以使用**命名函数表达式**达到目的。

```js
let factorial = function f(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * f(num - 1);
  }
};

let tfactorial = factorial;
factorial = null;
tfactorial(6); // 720
```

通过创建一个命名函数表达式 `f()`，然后赋值给 factorial。即使 factorial 赋值给其他变量，函数表达式 `f()` 名称不变，递归调用就不会有问题。这个模式在严格模式和非严格模式都可以使用。

## 10.13 尾调用优化 :star:

尾调用：外部函数的返回值时一个内部函数的返回值。

ECMAScript6 新增一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。

```js
function outerFunction() {
  return interFunction();
}
```

在 ES6 优化之前，执行这个例子会在内存发生如下操作：

1. 执行到 outerFunction 函数体，第一个栈帧被推到栈内；
2. 执行 outerFunction 函数体，到 return 语句，计算返回值必须先计算 innerFunction；
3. 执行到 innerFunction 函数体，第二个栈帧被推送到栈内；
4. 执行 innerFunction 函数体，计算其返回值；
5. 将返回值传回 outerFunction，然后 outerFunction 再返回值；
6. 将栈帧弹出栈外；

在 ES6 优化之后，执行这个例子会在内存中发生如下操作：

1. 执行到 outerFunction 函数体，第一个栈帧被推到栈内；
2. 执行 outerFunction 函数体，到 return 语句，为求值返回语句，必须先求值 innerFunction
3. 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction 的返回值；
4. 弹出 outerFunction 的栈帧；
5. 执行到 innerFunction 函数体，栈帧被推到栈内；
6. 执行 innerFunction 函数体，计算其返回值；
7. 将 innerFunction 的栈帧弹出栈外；

很明显，第一种情况每多调用一次嵌套函数，就增加一个栈帧。而第二种情况，无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。

### 10.13.1 尾调用优化的条件

尾调用优化的条件就是确定栈帧真的没有必要存在了，需满足以下条件：

- 代码在严格模式下执行；
- 外部函数的返回值是对尾调用函数的调用；
- 尾调用函数返回后不需要执行额外的逻辑；
- 尾调用函数不是引用外部函数作用域中的自由变量的闭包；

以下违反上述条件的函数实例，因此都不符合尾调用优化的条件：

```js
"use strict";

// 无优化：尾调用没有返回
function outerFunction() {
  innerFunction();
}

// 无优化：尾调用没有直接返回
function outerFunction() {
  const res = innerFunction();
  return res;
}

// 无优化：尾调用返回后进行类型转换逻辑
function outerFunction() {
  return innerFunction().toString();
}

// 无优化：尾调用是一个闭包
function outerFunction() {
  let foo = "bar";

  function innerFunction() {
    return foo;
  }

  return innerFunction();
}
```

下面是符合尾调用优化条件的例子

```js
"use strict";

// 有优化：栈帧销毁前执行参数计算
function outerFunction(a, b) {
  return innerFunction(a + b);
}

// 有优化：初始返回值不涉及栈帧
function outerFunction(a, b) {
  if (a < b) {
    return a;
  }
  return innerFunction(a + b);
}

// 有优化：两个内部函数都是在尾部
function outerFunction(condition) {
  return condition ? innerFunctionA() : innerFunctionB();
}
```

:::tip 注意
之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 `f.arguments` 和 `f.caller`，而它们都会引用外部函数的栈帧。
:::

### 10.13.2 尾调用优化的代码

斐波那契数列的函数 `F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）`

```js
function fib(n) {
  if (n < 2) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}
```

这种写法非常糟糕的，很显然这个函数不符合尾调用优化条件，因为返回语句中有相加的操作。内存复杂度为 `O(2^n)`。

当然解决这个问题也有不同策略，比如把递归改成迭代循环形式。

```js
function fib(n) {
  if (n < 2) {
    return n;
  }

  let x = 0,
    y = 1,
    temp,
    i = 2; //t相当于一个临时变量 用于将后面一个数传到前面
  while (n >= i) {
    temp = y;
    y = x + y;
    x = temp;
    i++;
  }
  return y;
}
```

不过，也可以保持递归实现，将其重构为满足优化条件的形式。为此使用两个嵌套函数，外部函数作为基础框架，内部函数执行递归函：

```js
"use strict";

// 框架函数
function fib(n) {
  return fibTmpl(0, 1, n);
}

// 执行递归
function fibTmpl(curr, next, n) {
  if (n === 0) {
    return curr;
  }
  return fibTmpl(next, curr + next, n - 1);
}
```

重构之后，就可以满足尾调用优化的所有的条件，再调用 `fib(1000)` 就不会对浏览器造成威胁了。
