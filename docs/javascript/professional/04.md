# 第四章 变量、作用域、内存

本章内容：

- 通过变量使用原始值和引用值；
- 理解执行上下文；
- 理解垃圾回收；

## 原始值和引用值

原始值：保存原始值的变量是**按值**（by value）访问的，操作的就是存储在变量的实际值。6 种原始值类型：Null、Undefined、String、Number、Boolean、Symbol。

引用值：保存在内存的对象。在 JavaScript 不允许直接访问内存地址，因此不能直接操作对象的内存空间。在操作对象时，实际上操作的是对该对象的**引用**（reference）而非对象本身。因此，保存应用值的变量是按应用访问。

### 动态属性

- 引用值：可以随时添加、修改、删除其属性和方法；
- 原始值：不能有属性，尽管尝试给原始值添加属性不会报错；

原始值初始化可以通过字面量形式，也可以通过使用 new 关键字，对比两种方式存在差异：

```js
let name1 = "js";
let name2 = "javascript";

name1.age = 10; // 原始值添加属性
name2.age = 10;

console.log(name1.age); // undefined
console.log(nam32.age); // 10
console.log(typeof name1); // string
console.log(typeof name2); // object
```

### 复制值

- 原始值：通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
- 引用值：从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。**这里的值实际是一个指针，它指向存储在堆内存中的对象**。复制完成之后，两个变量指向的同一个对象，因此在一个对象上面操作都会在另一个变量体现出来。

### 传递参数

- 原始值：在参数传递中，按值赋值函数参数，函数内操作不影响函数参数值；
- 引用值：在参数传递中，传递的是存储的指针，函数内操作会影响到函数外的值；

### 类型检测

- typeof 适合判断一个变量是否为原始值。用来判断是否是 string、boolean、number、undefined、symbol 的最好方式；
  - 对象和 null，则返回的是 object；
  - typeof 用于检测函数时，返回结果为 function；
- instanceof 是基于原型链判断的；
  - 规定所有引用值都是 Object 的实例；
- `Object.prototype.tostring.call()` 用来判断类型，返回结果 `[object 类型]`

> ECMA-262 规定，任何实现内部`[[Call]]`方法的对象都应该在 typeof 检测时返回 `function`。

## 执行上下文

变量和函数的上下文决定他们可以访问哪些数据，每一个上下为都有一个关联的对象；上下文在其所有代码执行完毕后会被销毁，包括定义在他上面的所有函数、变量。全局上下文在应用程序退出前会被笑销毁，比如关闭网页或浏览器。

- 全局作用域
  - 浏览器中，window 对象。let、const 声明的顶级变量不会定在全局上下文中，但是作用域链可以解析。
- 函数作用域
- 块级作用域

### 作用域链增强

一般执行上下文主要为全局上下文、函数上下文两种（eval() 调用内部存在第三种上下文）。但是存在其他方式增强作用域链，会在作用域链前端添加一个临时的上下文，在代码执行后删除。

- try...catch
- with

### 变量声明

声明变量关键字：var、let、const；

#### var 声明变量

- 存在变量提升，变量会被提升到作用域的顶部，提升即变量在声明之前可以调用；
- 可以重复声明；
- 变量未经声明直接赋值，那么这个变量会被提升到全局上下文中；

```js
// 未经声明，直接初始化
function foo(num1, num2) {
  sum = num1 + num2;
}
foo(1, 2);
console.log(sum);
```

#### let 块级作用域声明

- 不存在变量提升；
- 块级作用域。块级作用域由最近一对包含花括号`{}`界定。比如：if 块、while 块、function 块...
- 暂时性死区。即使用 let 声明变量之前，该变量是不可用的；
- 不能重复声明；

#### const 常量声明

- 声明时必须初始化值；
- const 声明的变量不能再被重新赋值或其他引用值（针对引用值）；
- 遵循 let 规则；

> const 声明的对象可以对对象属性进行修改。若是禁止修改，可以使用 `Object.freeze()`。

#### 标识符查找　

作用域链中的对象也有一个原型链，因此标识符查找可能会涉及到每一个对象的原型链。这个过程一直持续搜索到全局上下文变量对象，如果仍未找到，则说明变量未声明。

> 合理的创建局部变量会提升性能。访问局部变量比访问全局变量要快。

## 垃圾回收

常见 GC（垃圾回收：Garbage Collection）算法：标记清除、引用计数、标记整理算法；

| 算法     | 描述                                                                | 优点                                             | 缺点                                                               |
| -------- | ------------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------------ |
| 标记清除 | 分标记、清除两个阶段完成                                            | 可以回收循环引用的对象                           | 1. 容易产生碎片化空间，造成空间浪费；<br/> 2. 不能立即回收垃圾对象 |
| 引用计数 | 设置引用数, 引用关系发生变化时修改引用数字，引用数字为 0 时立即回收 | 1. 可以即时回收垃圾对象<br/> 2. 减少程序卡顿时间 | 1. 无法回收循环引用的对象 <br/>2. 资源消耗较大（使用计数器）       |
| 标记整理 | 标记整理可以看做时标记清除的增强                                    | 减少碎片空间                                     | 不会立即回收垃圾对象                                               |

```js
// 使用引用计数算法问题
// 该示例中存在循环引用问题，fn执行完毕后obj1、obj2并不会被回收掉
// 只是释放掉函数内部引用，但是存在对象属性的引用；
function fn() {
  const obj1 = {};
  const obj2 = {};

  obj1.name = obj2;
  obj2.name = obj1;
}
fn();
```

#### V8 中垃圾回收

- V8 是一款主流 JavaScript 执行引擎；
- V8 采用即时编译；
- V8 内存设限（64 位：1.5G，32 位：800M）；
  - 网页运行环境，
  - 内部垃圾回收机制限制；垃圾内存达到 1.5G 时，采用增量标记回收话，需要消耗 50ms，采用非标记增量回收，需要 1s

##### V8 垃圾回收策略：

- 采用分代回收思想
- 内存分为新生代、老生代存储区；
- 针对不同对象采用不同算法；

##### V8 中常用的 GC 算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

### 内存管理

解除引用：数据不再必要时，设置为 null 可以释放内存避免引用计数回收问题。适合全局变量和全局对象属性；

#### 通过 const、let 声明提升性能

let、const 都是以块（非函数）为作用域，所以相对 var 来说，会更早地让垃圾回收程序执行。

#### 隐藏类和删除操作

隐藏类：V8 JavaScript 引擎，创建的对象与隐藏类关联起来，已跟踪它们属性特征。能够共享相同隐藏类的对象性能会更好。动态删除、添加属性都会导致隐藏类失效。

- 避免使用“先创建再补充”式的动态属性赋值；
- 把不需要的属性值设置为 null；

#### 内存泄漏

- 意外声明全部变量；变量未声明直接赋值。
- 定时器也可能存在内存泄露；引用外部变量和函数，定时器存在，则引用一直有效。
- 闭包； 函数内部引用外部变量和函数。

## 小结

1. JavaScript 变量可以保存两种类型的值：原始值、引用值。原始值 6 中类型：Null、Undefined、Boolean、String、Number、Symbol。原始值和引用值有以下特点：

- 原始值大小固定，因此保存在栈内存上；
- 从一个变量复制到另一个变量，原始值按值复制；
- 引用值是对象，存储在推内存上；
- 包含引用值的变量实际上只包含指向该对象的指针，而不是对象本身；
- 从一个变量到另一个变量复制引用值，只会复制指针，因此两个变量指向同一个对象；
- `typeof` 操作符可以确定原始类型，而 `instanceof` 操作符用于确保值的引用类型；

2. 任何变量（原始值、引用值）都存在于某一个执行上下文中（即作用域）。这个上下文决定变量的生命周期。执行上下文可以总结为如下，

- 执行上下文分为：全局上下文、函数上下文、块级上下文；
- 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数；
- 函数或块的局部上下文不仅可以访问自己作用域内的变量，也可以访问任何包含上下文乃至全局上下文中的变量；
- 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据；
- 变量的执行上下文用于确定什么时候释放内存；

3. JavaScript 垃圾回收机制：

- 离开作用域的值会被自动标记可回收，然后在垃圾回收期间被删除；
- 标记清除，主流垃圾回收算法。分为标记和清除两个阶段，不会立即回收，容易产生碎片化空间；
- 引用计数，记录值被引用的次数，存在循环引用无法回收问题；
- 解除变量引用不仅可以消除循环引用，而且对垃圾回收也有帮助。促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。
